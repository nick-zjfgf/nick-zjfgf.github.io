<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git-reset]]></title>
    <url>%2F2017%2F12%2F19%2Fgit-reset%2F</url>
    <content type="text"><![CDATA[1、git log1git log 查看历史记录 2、reflog123456789101112131415161718git reflogc8f870f HEAD@&#123;0&#125;: reset: moving to c8f870f86a836f HEAD@&#123;1&#125;: reset: moving to 86a836fcb3f9a1 HEAD@&#123;2&#125;: reset: moving to cb3f9a186a836f HEAD@&#123;3&#125;: commit: ererererc8f870f HEAD@&#123;4&#125;: pull origin order: Fast-forwarde6ed90f HEAD@&#123;5&#125;: checkout: moving from thursday to ordercb3f9a1 HEAD@&#123;6&#125;: commit: erererer3a2dc37 HEAD@&#123;7&#125;: checkout: moving from order to thursdaye6ed90f HEAD@&#123;8&#125;: commit: ddddd1523a5f HEAD@&#123;9&#125;: commit (merge): Merge branch &apos;revert-9097312f&apos; into order8a0ca84 HEAD@&#123;10&#125;: checkout: moving from revert-9097312f to orderb0a1ae7 HEAD@&#123;11&#125;: checkout: moving from revert-8d0a42dc to revert-9097312f640aae1 HEAD@&#123;12&#125;: checkout: moving from order to revert-8d0a42dc8a0ca84 HEAD@&#123;13&#125;: pull origin order: Fast-forwardf7473e4 HEAD@&#123;14&#125;: checkout: moving from master to order9bf0448 HEAD@&#123;15&#125;: pull origin master: Fast-forward 1它会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中 3、利用reset命令本地进行还原1git reset --hard a1edaeb37a5 这看起来我们是丢掉了之前的提交记录，本地的修改也消失了，可以通过git reflog找回来 4、强制push 到远程仓库1git push -f http://root@10.112.1.199/lvmm_dest_project/lvmm_test.git master:master 5、help1git reset --help 6、模式(mode)1git reset --&lt;mode&gt; [&lt;commit&gt;] 123--soft 这个就是除了git commit 还原外其他的都保留，比如说git status 里面的内容和代码的修改。--mixed 这个就是 除了代码修改保留外其他的都还原， 包括git commit 和 git status 里面的内容。--hard 这个就将所有的都还原，包括代码 ，git add 后的内容以及 git commit 里面的内容。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分摊相关概念]]></title>
    <url>%2F2017%2F12%2F07%2Fbusiness-apportion%2F</url>
    <content type="text"><![CDATA[分摊]]></content>
      <tags>
        <tag>Business</tag>
        <tag>Apportion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BigData 读书杂记]]></title>
    <url>%2F2017%2F12%2F07%2Ftech-article-big-data%2F</url>
    <content type="text"><![CDATA[1、数据结构重要性 一个好的数据结构和一个糟糕的代码，比一个糟糕的数据结构和好的代码要强多了。–埃里克●雷蒙,美国软件开源运动的领导者，1999年 2、信息自由法 信息之于民主，就如货币之于经济–托马斯●杰斐逊（1743-1826），第3任美国总统 3、摩尔定律 摩尔定律已经成为工业界一切呈指数型增长事务的代名词。……下一个十年，摩尔定律可能还将有效……可以肯定的是，创新无止境。–戈登●摩尔，英特尔公司创始人，2003年 4、发展过程数据-&gt;信息-&gt;知识 数据：是对信息数字化的记录，其本身并无意义； 信息：是指把数据放置到一定的背景下，对数字进行解释、赋予意义。 例如：“1.85” 是个数据，“奥巴马身高1.85米”则是一条信息。 但进入信息时代之后，人们趋向把所有存储在计算机上的信息，无论是数字还是音乐、视频，都统称为数据。 5、最小数据集（Minimum Data Set，MDS）最小数据集是指通过手机最少的数据，最好地掌握一个研究对象所具有的特定或一件事情、一份工作所处的状态，其中核心是针对被观察的对象建立一套精简实用的数据指标。 6、软件的构成程序（代码）+数据（数据库）程序和数据的关系，就好像发动机和燃料，所有的程序，都是靠数据驱动的，数据之于程序，又好比血液之于人体，一旦血液停止流动，人就失去了生命，代码也将停止运行。 7、普适计算 &lt;/div》]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>BigData</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK 线程]]></title>
    <url>%2F2017%2F12%2F01%2Fjava-policy%2F</url>
    <content type="text"><![CDATA[一、饱和策略1.1 AbortPolicy中止策略该策略是默认饱和策略。12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString());&#125; 1.2 DiscardPolicy抛弃策略123public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; //不做处理，抛弃&#125; 1.3 DiscardOldestPolicy抛弃旧任务策略123456public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125;&#125; 如代码，先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。 1.4 CallerRunsPolicy调用者运行12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125;&#125; 既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。]]></content>
      <tags>
        <tag>java</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态数据源实现]]></title>
    <url>%2F2017%2F11%2F20%2Fdynamic-datasource%2F</url>
    <content type="text"><![CDATA[1.AOP实现动态jdbc切换12345678910111213package com.lvmama.datasource.config;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DynamicDataSourceContextHolder.getDataSourceType(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.lvmama.datasource.config;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;@Aspect@Order(-1)// 保证该AOP在@Transactional之前执行@Componentpublic class DynamicDataSourceAspect &#123; private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); @Before(&quot;@annotation(ds)&quot;) public void changeDataSource(JoinPoint point, TargetDataSource ds) throws Throwable &#123; String dsId = ds.name(); if (!DynamicDataSourceContextHolder.containsDataSource(dsId)) &#123; logger.error(&quot;数据源[&#123;&#125;]不存在，使用默认数据源 &gt; &#123;&#125;&quot;, ds.name(), point.getSignature()); &#125; else &#123; logger.debug(&quot;Use DataSource : &#123;&#125; &gt; &#123;&#125;&quot;, ds.name(), point.getSignature()); DynamicDataSourceContextHolder.setDataSourceType(ds.name()); &#125; &#125; @After(&quot;@annotation(ds)&quot;) public void restoreDataSource(JoinPoint point, TargetDataSource ds) &#123; logger.debug(&quot;Revert DataSource : &#123;&#125; &gt; &#123;&#125;&quot;, ds.name(), point.getSignature()); DynamicDataSourceContextHolder.clearDataSourceType(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package com.lvmama.datasource.config;import java.util.ArrayList;import java.util.List;public class DynamicDataSourceContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); public static List&lt;String&gt; dataSourceIds = new ArrayList&lt;&gt;(); public static void setDataSourceType(String dataSourceType) &#123; contextHolder.set(dataSourceType); &#125; public static String getDataSourceType() &#123; return contextHolder.get(); &#125; public static void clearDataSourceType() &#123; contextHolder.remove(); &#125; /** * 判断指定DataSrouce当前是否存在 * * @param dataSourceId * @return * @author SHANHY * @create 2016年1月24日 */ public static boolean containsDataSource(String dataSourceId)&#123; return dataSourceIds.contains(dataSourceId); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.lvmama.datasource.config;import java.util.HashMap;import java.util.Map;import javax.sql.DataSource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.PropertyValues;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.GenericBeanDefinition;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.bind.RelaxedDataBinder;import org.springframework.boot.bind.RelaxedPropertyResolver;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.convert.ConversionService;import org.springframework.core.convert.support.DefaultConversionService;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotationMetadata;public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware&#123; private static final Logger logger = LoggerFactory.getLogger(DynamicDataSourceRegister.class); private ConversionService conversionService = new DefaultConversionService(); private PropertyValues dataSourcePropertyValues; // 如配置文件中未指定数据源类型，使用该默认值 private static final Object DATASOURCE_TYPE_DEFAULT = &quot;com.alibaba.druid.pool.DruidDataSource&quot;; // 数据源 private DataSource defaultDataSource; private Map&lt;String, DataSource&gt; customDataSources = new HashMap&lt;&gt;(); @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;Object, Object&gt;(); // 将主数据源添加到更多数据源中 targetDataSources.put(&quot;dataSource&quot;, defaultDataSource); DynamicDataSourceContextHolder.dataSourceIds.add(&quot;dataSource&quot;); // 添加更多数据源 targetDataSources.putAll(customDataSources); for (String key : customDataSources.keySet()) &#123; DynamicDataSourceContextHolder.dataSourceIds.add(key); &#125; // 创建DynamicDataSource GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(DynamicDataSource.class); beanDefinition.setSynthetic(true); MutablePropertyValues mpv = beanDefinition.getPropertyValues(); mpv.addPropertyValue(&quot;defaultTargetDataSource&quot;, defaultDataSource); mpv.addPropertyValue(&quot;targetDataSources&quot;, targetDataSources); registry.registerBeanDefinition(&quot;dataSource&quot;, beanDefinition); logger.info(&quot;Dynamic DataSource Registry&quot;); &#125; @SuppressWarnings(&quot;unchecked&quot;) public DataSource buildDataSource(Map&lt;String, Object&gt; dsMap) &#123; try &#123; Object type = dsMap.get(&quot;type&quot;); if (type == null) type = DATASOURCE_TYPE_DEFAULT;// 默认DataSource Class&lt;? extends DataSource&gt; dataSourceType; dataSourceType = (Class&lt;? extends DataSource&gt;) Class.forName((String) type); String driverClassName = dsMap.get(&quot;driver-class-name&quot;).toString(); String url = dsMap.get(&quot;url&quot;).toString(); String username = dsMap.get(&quot;username&quot;).toString(); String password = dsMap.get(&quot;password&quot;).toString(); DataSourceBuilder factory = DataSourceBuilder.create().driverClassName(driverClassName).url(url) .username(username).password(password).type(dataSourceType); return factory.build(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 加载多数据源配置 */ @Override public void setEnvironment(Environment env) &#123; initDefaultDataSource(env); initCustomDataSources(env); &#125; private void initDefaultDataSource(Environment env) &#123; // 读取主数据源 RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(env, &quot;spring.datasource.&quot;); Map&lt;String, Object&gt; dsMap = new HashMap&lt;&gt;(); dsMap.put(&quot;type&quot;, propertyResolver.getProperty(&quot;type&quot;)); dsMap.put(&quot;driver-class-name&quot;, propertyResolver.getProperty(&quot;driver-class-name&quot;)); dsMap.put(&quot;url&quot;, propertyResolver.getProperty(&quot;url&quot;)); dsMap.put(&quot;username&quot;, propertyResolver.getProperty(&quot;username&quot;)); dsMap.put(&quot;password&quot;, propertyResolver.getProperty(&quot;password&quot;)); defaultDataSource = buildDataSource(dsMap); dataBinder(defaultDataSource, env); &#125; private void dataBinder(DataSource dataSource, Environment env)&#123; RelaxedDataBinder dataBinder = new RelaxedDataBinder(dataSource); //dataBinder.setValidator(new LocalValidatorFactory().run(this.applicationContext)); dataBinder.setConversionService(conversionService); dataBinder.setIgnoreNestedProperties(false);//false dataBinder.setIgnoreInvalidFields(false);//false dataBinder.setIgnoreUnknownFields(true);//true if(dataSourcePropertyValues == null)&#123; Map&lt;String, Object&gt; rpr = new RelaxedPropertyResolver(env, &quot;spring.datasource&quot;).getSubProperties(&quot;.&quot;); Map&lt;String, Object&gt; values = new HashMap&lt;&gt;(rpr); // 排除已经设置的属性 values.remove(&quot;type&quot;); values.remove(&quot;driver-class-name&quot;); values.remove(&quot;url&quot;); values.remove(&quot;username&quot;); values.remove(&quot;password&quot;); dataSourcePropertyValues = new MutablePropertyValues(values); &#125; dataBinder.bind(dataSourcePropertyValues); &#125; private void initCustomDataSources(Environment env) &#123; // 读取配置文件获取更多数据源，也可以通过defaultDataSource读取数据库获取更多数据源 RelaxedPropertyResolver propertyResolver = new RelaxedPropertyResolver(env, &quot;custom.datasource.&quot;); String dsPrefixs = propertyResolver.getProperty(&quot;names&quot;); for (String dsPrefix : dsPrefixs.split(&quot;,&quot;)) &#123;// 多个数据源 Map&lt;String, Object&gt; dsMap = propertyResolver.getSubProperties(dsPrefix + &quot;.&quot;); DataSource ds = buildDataSource(dsMap); customDataSources.put(dsPrefix, ds); dataBinder(ds, env); &#125; &#125;&#125; 123456789101112131415package com.lvmama.datasource.config;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource &#123; String name();&#125; 2.动态实现jdbc及es切换1234567891011package com.lvmama.datasource.service.strategy.base;import org.springframework.beans.factory.InitializingBean;public class BaseStrategy&lt;T&gt; implements InitializingBean&#123; @Override public void afterPropertiesSet() throws Exception &#123; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lvmama.datasource.service.strategy.base;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Value;import com.lvmama.context.ApplicationContextUtil;public class FrontBaseStrategy&lt;T&gt; extends BaseStrategy&lt;T&gt; &#123; protected T clientService; protected static final String REMOTE = &quot;Remote&quot;; @Value(&quot;$&#123;service_strategy&#125;&quot;) private String strategy; private Class&lt;T&gt; entityClass; private String genericSimpleName; @SuppressWarnings(&quot;unchecked&quot;) public FrontBaseStrategy() &#123; super(); //子类中保存父类泛型，父类中保存不了泛型，会泛型擦除 类似HibernateBaseDao&lt;T&gt; implements BaseDao&lt;T&gt; Type genType = this.getClass().getGenericSuperclass(); Type[] params = ((ParameterizedType) genType).getActualTypeArguments(); entityClass = (Class&lt;T&gt;) params[0]; genericSimpleName = entityClass.getSimpleName(); &#125; @SuppressWarnings(&quot;unchecked&quot;) @Override public void afterPropertiesSet() throws Exception &#123; this.initClientService(this.strategy); &#125; protected void initClientService(String strategy1)&#123; if(StringUtils.isNotBlank(strategy1))&#123; this.clientService = (T) ApplicationContextUtil.getBean(strategy1 + genericSimpleName); &#125;else&#123; this.clientService = (T) ApplicationContextUtil.getBean(this.strategy + genericSimpleName); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930package com.lvmama.datasource.service.strategy.impl;import javax.transaction.Transactional;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import com.lvmama.datasource.service.base.IUserBaseService;import com.lvmama.datasource.service.strategy.IUserBaseStrategyService;import com.lvmama.datasource.service.strategy.base.FrontBaseStrategy;@Component(&quot;userStrategyService&quot;)public class UserStrategyServiceImpl extends FrontBaseStrategy&lt;IUserBaseService&gt; implements IUserBaseStrategyService &#123; @Value(&quot;$&#123;user_strategy:&#125;&quot;) private String strategy; @Override public void afterPropertiesSet() throws Exception &#123; this.initClientService(strategy); &#125; @Override public int count() &#123; return this.clientService.count(); &#125;&#125; 1234567891011121314151617181920212223242526272829package com.lvmama.datasource.service.mybatis;import java.util.List;import javax.annotation.Resource;import javax.transaction.Transactional;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service;import com.lvmama.datasource.config.TargetDataSource;import com.lvmama.datasource.dao.mybatis.UserMyBatisDao;import com.lvmama.datasource.domain.User;import com.lvmama.datasource.service.base.IUserBaseService;@Service(&quot;mybatisIUserBaseService&quot;)@Transactionalpublic class UserMybatisServiceImpl implements IUserBaseService &#123; @Resource private UserMyBatisDao userMyBatisDao; @Override @TargetDataSource(name =&quot;ds2&quot;) public int count() &#123; return userMyBatisDao.count(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring异步任务，@Async配置和使用]]></title>
    <url>%2F2017%2F11%2F13%2Fspring-async%2F</url>
    <content type="text"><![CDATA[一、描述这个注解用于标注某个方法或某个类里面的所有方法都是需要异步处理的。被注解的方法被调用的时候，会在新线程中执行，而调用它的方法会在原来的线程中执行。这样可以避免阻塞、以及保证任务的实时性。适用于处理log、发送邮件、短信……等。 二、应用范围 类：表示这个类中的所有方法都是异步的； 方法：表示这个方法是异步的，如果类也注解了，则以这个方法的注解为准。 三、相关配置1.&lt;task:annotation-driven /&gt; executor：指定一个缺省的executor给@Async使用。 例子：&lt;task:annotation-driven executor=&quot;asyncExecutor&quot; /&gt; 2.&lt;task:executor /&gt; id：当配置多个executor时，被@Async(“id”)指定使用；也被作为线程名的前缀。 pool-size： core size：最小的线程数，缺省：1 max size：最大的线程数，缺省：Integer.MAX_VALUE queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这时系统会拒绝这个任务并抛出TaskRejectedException异常（缺省配置的情况下，可以通过rejection-policy来决定如何处理这种情况）。缺省值为：Integer.MAX_VALUE keep-alive：超过core size的那些线程，任务完成后，再经过这个时长（秒）会被结束掉 rejection-policy：当pool已经达到max size的时候，如何处理新任务 ABORT（缺省）：抛出TaskRejectedException异常，然后不执行 DISCARD：不执行，也不抛出异常 DISCARD_OLDEST：丢弃queue中最旧的那个任务 CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 3.配置例子12&lt;task:annotation-driven executor=&quot;asyncExecutor&quot; /&gt;&lt;task:executor id=&quot;asyncExecutor&quot; pool-size=&quot;100-10000&quot; queue-capacity=&quot;10&quot;/&gt; 实例：123456&lt;!-- 缺省的异步任务线程池 --&gt; &lt;task:annotation-driven executor=&quot;asyncExecutor&quot; /&gt; &lt;task:executor id=&quot;asyncExecutor&quot; pool-size=&quot;100-10000&quot; queue-capacity=&quot;10&quot; /&gt; &lt;!-- 处理log的线程池 --&gt; &lt;task:executor id=&quot;logExecutor&quot; pool-size=&quot;15-1000&quot; queue-capacity=&quot;5&quot; keep-alive=&quot;5&quot;/&gt; 123456@Override @Async(&quot;logExecutor&quot;) //如果不指定名字，会使用缺省的“asyncExecutor” public void saveUserOpLog(TabUserOpLog tabUserOpLog) &#123; userOpLogDAO.insertTabUserOpLog(tabUserOpLog); &#125; 4.线程的优先级和类型： 优先级：NORM_PRIORITY 类型：非守护线程 用户线程（User Thread）：JVM会等待所有的用户线程结束后才退出；当系统中没有用户线程了，JVM也就退出了 守护线程（Daemon Thread）：一般是为其他线程提供服务的线程，比如GC垃圾回收器；JVM退出时，不会管守护线程是否存在，而是直接退出 所以，对于文件、数据库的操作，不适宜使用守护线程，不然可能会丢失数据！ 4.附1234567891011121314151617181920212223242526272829@Configuration @EnableAsync public class SpringConfig &#123; /** Set the ThreadPoolExecutor&apos;s core pool size. */ private int corePoolSize = 10; /** Set the ThreadPoolExecutor&apos;s maximum pool size. */ private int maxPoolSize = 200; /** Set the capacity for the ThreadPoolExecutor&apos;s BlockingQueue. */ private int queueCapacity = 10; private String ThreadNamePrefix = &quot;MyLogExecutor-&quot;; @Bean public Executor logExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setQueueCapacity(queueCapacity); executor.setThreadNamePrefix(ThreadNamePrefix); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
</search>
